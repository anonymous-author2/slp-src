#!/usr/bin/env python
import numpy as np
import math
import rospy
import signal
#https://github.com/eric-wieser/ros_numpy
import ros_numpy
import sys
import cv2
from threading import Event, Timer
from std_msgs.msg import String
from sensor_msgs.msg import Image, PointCloud2, CameraInfo, JointState
import image_geometry
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker
from geometry_msgs.msg import TransformStamped, PoseStamped, Point, Pose, PoseArray, Quaternion, Twist, Vector3
from std_msgs.msg import ColorRGBA
from slp_msgs.msg import Action, Command, POI, POIArray
from robot_msgs.msg import HybridPose
import copy
from tf.transformations import quaternion_from_euler
import tf
import tf2_ros
import tf2_geometry_msgs
import PyKDL
import types
from scipy.spatial import ConvexHull
from functools import cmp_to_key



REFERENCE_FRAME='panda_link0'
CAMERA_FRAME='internal_rgb_camera_link'

class Parser(object):
    def __init__(self):

        self._joints = None
        self._camera_t = None
        self._freq = 1
        self._saved_view = []
        self._depth = None
        self._numpy_depth = None
        self._new_depth = True
        self._behavior_recording = False
        self._behaviors = []#["Move:screw_1-box_0;Reset"]
        self._actions_recorded = []
        self._triggers = {}
        self._moving = False
        self._zones = {}
        self._pause_autonomy = False
        self._waiting_world_state = False
        self._conflict = None

        self._tfBuffer = tf2_ros.Buffer()
        self._tl = tf2_ros.TransformListener(self._tfBuffer)
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._pose_pub = rospy.Publisher("/grasping_point",PoseStamped,queue_size=1)
        self._command_pub = rospy.Publisher("/parser/command", Command, queue_size=1)
        self._marker_pub = rospy.Publisher("/gui/markers", Marker, queue_size=1)

        self._virtual = rospy.get_param('~only_virtual')
        self._camera_topic = "/rgb/" if not self._virtual else "/virtual_camera/"

        self._model = image_geometry.PinholeCameraModel()
        self._model.fromCameraInfo(rospy.wait_for_message(self._camera_topic+"camera_info", CameraInfo))

        self._gui_pub = rospy.Publisher("/parser/gui_info",String,queue_size=1)
        self._panda_command = rospy.Publisher("/panda/commands",String, queue_size=1)

        self._br = tf2_ros.TransformBroadcaster()
        rospy.sleep(.5)
        self._pois = []
        self._poi_gui = ""
        self._poi_sub = rospy.Subscriber("/world_state/pois", POIArray, self.on_poi, queue_size = 1)
        self._command_sub = rospy.Subscriber("/gui/command", String, self.on_command, queue_size = 1)
        self._event_sub = rospy.Subscriber("/event", String, self.on_event, queue_size = 1)
        self._event_pub = rospy.Publisher("/event", String, queue_size = 1)
        if self._virtual:
            self._joint_sub = rospy.Subscriber("/simulator/joint_states", JointState, self.on_joints)
        else:
            self._joint_sub = rospy.Subscriber("/panda/joint_states", JointState, self.on_joints)
        self._depth_sub = rospy.Subscriber("depth_to_rgb/image_raw", Image, self.on_depth)
    
    def on_depth(self,msg):
        self._depth = msg
        self._new_depth = True

    def on_joints(self, msg):
        self._joints = msg.position

    def on_event(self, msg):
        l = msg.data.split(";")
        event = l[0]
        
        #if event.startswith("trigger"):
        #    #data: "trigger_1;screw;pix_pos:1200-1350_750-950"
        #    t = types.SimpleNamespace()
        #    t.view_point = PoseStamped()
        #    t.id = l[0]
        #    t.object = l[1]
        #    t.conditions = l[2].split(",")
        #    t.behavior = len(self._behaviors)
        #    self._triggers = [t]
        #if event == "record":
        #    self._behavior_recording = True
        #if event == "stop_record":
        #    self._behavior_recording = False
        #    if len(self._actions_recorded) != 0:
        #        self._event_pub.publish("recorded;"+"behavior_"+str(len(self._behaviors))+";"+";".join(self._actions_recorded))
        #        self._behaviors.append(";".join(copy.deepcopy(self._actions_recorded)))
        #        self._actions_recorded = []

        if event == "motion_finished" or event == "wait":
            self.publish_pois()
            #self._event_pub.publish("display_message;Robot is idle")

        if event == "reset_triggers_zones":
            self._event_pub.publish("display_message;Resetting")
            self._triggers = {}
            self._zones = {}

        #if event == "action_finished" and self._behavior_recording:
        #    self._actions_recorded.append(l[1])
        
        if msg.data == "start_exec":
            self._moving = True
        
        if msg.data == "motion_finished":
            print("not moving")
            self._moving = False
            if not self._waiting_world_state:
                self._event_pub.publish("display_message;Robot analyzing workspace")
                self._waiting_world_state = True
                t = Timer(1.5, self.ready_to_go) 
                t.start()
        
        if msg.data == "pause_autonomy":
            self._event_pub.publish("display_message;Rules Paused")
            self._pause_autonomy = True
        
        if msg.data == "resume_autonomy":
            self._event_pub.publish("display_message;Rules Resumed")
            self._pause_autonomy = False

    def ready_to_go(self):
        print("ready to go")
        if not self._moving:
            self._event_pub.publish("display_message;Robot Idle")
        self._waiting_world_state = False

    def on_poi(self, msg):
        self._pois = []
        for p in msg.poi_array:
            self._pois.append(p)
        self.publish_pois()

    def publish_pois(self):
        
        done = False
        while not done:
            self._poi_gui="poi;"
            try:
                for p in self._pois:
                    #Inform interface of poi
                    pixel = self.get_pixel_from_pose_as_string(p.pose)
                    if pixel is None:
                        continue
                    name = self.get_name(p)
                    self._poi_gui+=name+":"+pixel+":"+p.state.data+";"
                
                for name, hull  in self._zones.items():
                    self._poi_gui+="zone:"+name+":"
                    for i, point in enumerate(hull.points):
                        p = Point(point[0],point[1],0)

                        pixels = self.get_pixel_from_point(p)
                        self._poi_gui+=pixels + ":" 
                        #self.send_point(p,name+str(i))
                    self._poi_gui = self._poi_gui[:-1]+";"

                    #points = hull.points
                    #rows = 3
                    #cols = 1
                    #left = np.linspace(points[0], points[3], rows+1)
                    #right = np.linspace(points[1], points[2], rows+1)
                    #bot = np.linspace(left[0], right[0], cols+1)
                    #for i in range(rows):
                    #    top = bot
                    #    bot = np.linspace(left[i+1], right[i+1], cols+1)
                    #    for j in range(cols):
                    #        hull = ConvexHull([top[j],top[j+1],bot[j+1],bot[j]])
                    #        p = Point(hull.points.mean(0)[0],hull.points.mean(0)[1],0)
                    #        self.send_point(p,name+str(i)+"_"+str(j))



                self._poi_gui = self._poi_gui[:-1]
                self._gui_pub.publish(self._poi_gui)
                done = True
            except:
                pass

    def send_point(self, p, name):
        t = TransformStamped()

        t.header.stamp = rospy.Time.now()
        t.header.frame_id = "panda_link0"
        t.child_frame_id = name
        t.transform.translation = p
        t.transform.rotation.w = 1
        self._br.sendTransform(t)


    def get_vect(self, v):
        toreturn = []
        try:
            toreturn.append(v.x)
            toreturn.append(v.y)
            toreturn.append(v.z)
            toreturn.append(v.w)
        except:
            pass
        return toreturn

    def get_name(self, poi):
        return poi.type.data + ":" + str(poi.id)

    def get_pose_from_pixel(self,x,y):
        if self._depth is None: 
            return None
        if self._new_depth:
            self._numpy_depth = ros_numpy.numpify(self._depth)
            self._new_depth = False
        d = self._numpy_depth[y,x]
        if d == 0.0:
            print("bad depth")
            self._gui_pub.publish(String("bad_depth"))
            return None
        point = self.get_xyz_from_pixel(x,y,d)
        p = PoseStamped()
        p.header.frame_id = CAMERA_FRAME
        p.header.stamp = rospy.Time(0)
        p.pose.position = point
        p.pose.orientation.w = 1
        return p

    def get_rotated_point(self, coord):
        coord = coord.split('/')
        p = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
        if p == None:
            return None
        p = self._tfBuffer.transform(p,REFERENCE_FRAME)
        q = PyKDL.Rotation.RPY(0,0,float(coord[2])/180*np.pi).GetQuaternion()
        p.pose.orientation.x=q[0]
        p.pose.orientation.y=q[1]
        p.pose.orientation.z=q[2]
        p.pose.orientation.w=q[3]
        h = self.get_hybrid_pose(p)
        return h

    def get_xyz_from_pixel(self,x,y,d):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)
        point = Point()
        point.x=d/p3d[2]*p3d[0]
        point.y=d/p3d[2]*p3d[1]
        point.z=d/p3d[2]*p3d[2]
        return point
    
    def get_pixel_from_pose(self, pose, viewpoint = None):
        if viewpoint is None:
            p = self._tfBuffer.transform(pose,CAMERA_FRAME)
        p = p.pose.position
        if p.z < 0:
            return None
        p=[p.x,p.y,p.z]
        return self._model.project3dToPixel(p)
    
    def get_pixel_from_pose_as_string(self, pose, viewpoint = None):
        pixel = self.get_pixel_from_pose(pose, viewpoint)
        if pixel is None:
            return pixel
        return str(int(pixel[0]))+","+str(int(pixel[1]))

    def get_pixel_from_point(self, p):
        pose = PoseStamped()
        pose.pose.position = p
        pose.pose.orientation.w = 1
        pose.header.frame_id = REFERENCE_FRAME
        return self.get_pixel_from_pose_as_string(pose)

    def publish_pose(self,point):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id=CAMERA_FRAME
        pose = self._tfBuffer.transform(pose,REFERENCE_FRAME)
        q = tf.transformations.quaternion_from_euler(math.pi,0,0)
        pose.pose.orientation.x=q[0]
        pose.pose.orientation.y=q[1]
        pose.pose.orientation.z=q[2]
        pose.pose.orientation.w=q[3]
        pose.header.stamp=rospy.Time.now()
        self._pose_pub.publish(pose)

    def get_orientation_from_quaternion(self, q):
        rot = Quaternion()
        rot.x=q[0]
        rot.y=q[1]
        rot.z=q[2]
        rot.w=q[3]
        return rot

    def get_hybrid_pose(self, p):
        h = HybridPose()
        h.header = p.header
        h.pose = p.pose
        h.sel_vector = [1,1,1,1,1,1]
        h.constraint_frame.w = 1
        return h

    #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
    def get_color(self, string, alpha):
        color = ColorRGBA()
        string=string.lstrip('#')
        (r,g,b) = tuple(int(string[i:i+2], 16)/255. for i in (0, 2, 4))
        color.r = r
        color.g = g
        color.b = b
        color.a=alpha
        return color

    def get_points(self, cmd):
        l = cmd.split("_")
        points = []
        for p in l:
            point = Point()
            coord = p.split(',')
            point.x = int(coord[0])
            point.y = int(coord[1])
            points.append(point)
        return points

    def get_pose_from_trans(self, t):
        pose = HybridPose()
        pose.pose.position.x = t.transform.translation.x
        pose.pose.position.y = t.transform.translation.y
        pose.pose.position.z = t.transform.translation.z
        pose.pose.orientation.x = t.transform.rotation.x
        pose.pose.orientation.y = t.transform.rotation.y
        pose.pose.orientation.z = t.transform.rotation.z
        pose.pose.orientation.w = t.transform.rotation.w
        pose.sel_vector=[1,1,1,1,1,1]
        pose.constraint_frame.w = 1
        return pose


    def on_command(self, message):
        list_actions = message.data.split(";")
        command_type = list_actions[0]
        if command_type == "pause":
            self._event_pub.publish("pause")
            return
        #if command_type == "play":
        #    self._event_pub.publish("play")
        #    return
        if command_type == 'init_gui' or command_type == "lock":
            self.publish_pois()
        if command_type == 'save_view' and self._joints is not None:
            n = int(list_actions[1])
            if n > len(self._saved_view) - 1:
                self._saved_view.append(self._joints)
            else:
                self._saved_view[n] = self._joints
            return

        if command_type.startswith("trigger"):
            #data: "trigger_1;screw;pix_pos:1200-1350_750-950"
            name = list_actions[0]
            t = types.SimpleNamespace()
            t.view_point = PoseStamped()
            #t.object = list_actions[1]

            t.conditions = self.parse_conditions(list_actions[1].split(","))
            
            t.behavior = list_actions[2]
            t.priority = 0
            self._triggers[name] = t
            self._event_pub.publish("display_message;Trigger Created")
            return
            
        if command_type.startswith("button_trigger"):
            button_name = list_actions[1]
            for name in self._triggers:
                t = self._triggers[name]
                t.candidates = self._pois
                print(t.conditions)
                print(button_name)
                if t.conditions == button_name:
                    t.name = name
                    actions = self.parse_actions(t.behavior.split(","),t.candidates) 
                    if actions is None:
                        continue    
                    self.run_trigger(t)
                    break
            return

        if command_type == "delete_trigger":
            try:
                self._triggers.pop(list_actions[1])
                self._event_pub.publish("display_message;Trigger Deleted")
            except:
                print("No trigger named "+list_actions[1])
            return
        
        if command_type == "priority":
            name = list_actions[1].split(",")[0]
            reason = list_actions[1].split(",")[1]
            if not name in self._conflict:
                return
            if reason == "always":
                for name2 in self._triggers:
                    if name2 in self._conflict and name2 != name:
                        self._triggers[name2].priority = min(self._triggers[name2].priority,self._triggers[name].priority-1)

            t = self._triggers[name]
            t.name = name
            t.candidates = self.get_candidates(t.conditions)
            actions = self.parse_actions(t.behavior.split(","),t.candidates) 
            if actions is None:
                return 
            self.run_trigger(t)
            self._pause_autonomy = False
            return

        if command_type == 'load_view':
            n = int(list_actions[1])
            if n < len(self._saved_view):
                action = Action()
                action.poses.header.frame_id = REFERENCE_FRAME
                action.type = action.MOVE_ANGLE
                action.joint_pose = self._saved_view[n]
                pose = HybridPose()
                pose.constraint_frame.w = 1
                action.poses.poses.append(pose)
                cmd = Command()
                cmd.type = cmd.EXEC
                cmd.core_action.append(action)
                self._command_pub.publish(cmd)
                return

        #if command_type == 'play':
        #    n = int(list_actions[1])
        #    if n < len(self._saved_view):
        #        action = Action()
        #        action.poses.header.frame_id = REFERENCE_FRAME
        #        action.type = action.MOVE_ANGLE
        #        action.joint_pose = self._saved_view[n]
        #        pose = HybridPose()
        #        pose.constraint_frame.w = 1
        #        action.poses.poses.append(pose)
        #        cmd = Command()
        #        cmd.type = cmd.EXEC
        #        cmd.core_action.append(action)
        #        self._command_pub.publish(cmd)
        #        return

        if command_type == "new_zone" or command_type == "update_zone":
            name = list_actions[1].split(":")[0]
            hull = self.get_hull_from_pixel(list_actions[1].split(":")[1])
            self._zones[name]=hull
            print(command_type)
            print(self._zones)
            if command_type == "new_zone":
                self._event_pub.publish("zone_created;"+name)
                self._event_pub.publish("display_message;"+name.replace("_"," ")+" Updated")
            else:
                self._event_pub.publish("zone_updated;"+name)
                self._event_pub.publish("display_message;"+name.replace("_"," ")+" Updated")
            return
        
        if command_type == "delete_zone":
            try:
                self._zones.pop(list_actions[1])
                self._event_pub.publish("zone_deleted;"+list_actions[1])
                self._event_pub.publish("display_message;"+list_actions[1].replace("_"," ")+" Deleted")
            except:
                print("no zone named "+list_actions[1])
            return

        if command_type == 'panda_goal':
            pose = [float(v) for v in list_actions[1].split(",")]
            r = [p*np.pi/180. for p in pose[3:]]
            rot = PyKDL.Rotation.RPY(r[0],r[1],r[2])
            q = rot.GetQuaternion()
            action = Action()
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position.x = pose[0]
            action.pose.pose.position.y = pose[1]
            action.pose.pose.position.z = pose[2]
            action.pose.pose.orientation.x = q[0]
            action.pose.pose.orientation.y = q[1]
            action.pose.pose.orientation.z = q[2]
            action.pose.pose.orientation.w = q[3]
            action.pose.sel_vector = [1,1,1,1,1,1]
            action.pose.constraint_frame.w = 1
            action.type = action.MOVE
            
            ee_t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, 'panda_gripper', rospy.Time(0)).transform
            if action.pose.pose.position.z < .08 and ee_t.translation.z > action.pose.pose.position.z:
                action.type = action.MOVE_FORCE
            
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'center':
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, 'rotated_camera', rospy.Time(0)).transform
            p = t.translation
            q = t.rotation
            e = tf.transformations.euler_from_quaternion([q.x,q.y,q.z,q.w])
            r = [e[0],e[1],e[2]]

            dimensions = list_actions[1].split(",")
            if "x" in dimensions:
                r[0] = 0
            if "y" in dimensions:
                r[1] = 0
            if "z" in dimensions:
                r[2] = 0
            

            rot = PyKDL.Rotation.RPY(r[0],r[1],r[2])
            q = rot.GetQuaternion()
            action = Action()
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position.x = p.x
            action.pose.pose.position.y = p.y
            action.pose.pose.position.z = p.z
            action.pose.pose.orientation.x = q[0]
            action.pose.pose.orientation.y = q[1]
            action.pose.pose.orientation.z = q[2]
            action.pose.pose.orientation.w = q[3]
            action.pose.sel_vector = [1,1,1,1,1,1]
            action.pose.constraint_frame.w = 1
            action.type = action.VIEW
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'direct': 
            cmd = list_actions[1].split(":")
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = self.get_action_from_name(action,cmd[0])

            if cmd[0] == "test":
                point = cmd[1]
                coord = point.split(',')
                p = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))             
                if p is not None:
                    p = self._tfBuffer.transform(p,REFERENCE_FRAME)
                    print(p.pose.position)
                    #if p.pose.position.x>.67 or p.pose.position.y > 0.30:
                    #    self._gui_pub.publish(String("out_of_reach"))
                    #    return      
                    self._gui_pub.publish(String("good_move"))
                    t = TransformStamped()
                    t.header = p.header
                    t.header.stamp = rospy.Time.now()
                    t.child_frame_id = "target"
                    t.transform.translation = p.pose.position
                    t.transform.rotation = p.pose.orientation
                    self._br.sendTransform(t)
                    print("sent")
                return
            if cmd[0] == "Go":
                delta = cmd[1].split(',')
                t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
                pose = self.get_pose_from_trans(t)
                pose.pose.position.x += float(delta[0])/1000.
                pose.pose.position.y += float(delta[1])/1000.
                pose.pose.position.z += float(delta[2])/1000.

                ee_t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, 'panda_gripper', rospy.Time(0)).transform
                if pose.pose.position.z < .08 and ee_t.translation.z > pose.pose.position.z:
                    action.type = action.MOVE_FORCE

                action.poses.poses.append(pose)
                action.pose = pose
            elif len(cmd) == 1:
                pass
            elif cmd[1].find(",") == -1:
                item = cmd[1]
                t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item, rospy.Time(0)) 
                pose = self.get_pose_from_trans(t)
                action.poses.poses.append(pose)
                action.pose = pose
                action.item = String(item)
            else:
                points = cmd[1]
                coord = points.split(',')
                target = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
                if target == None:
                    return
                target = self._tfBuffer.transform(target,REFERENCE_FRAME)
                target.pose.position.z = max(target.pose.position.z,0.01) 
                #print(target.pose.position.z)
                q = PyKDL.Rotation.RPY(0,0,float(coord[2])/180*np.pi).GetQuaternion()
                target.pose.orientation.x=q[0]
                target.pose.orientation.y=q[1]
                target.pose.orientation.z=q[2]
                target.pose.orientation.w=q[3]
                h = HybridPose()
                h.header = target.header
                h.pose = target.pose
                h.sel_vector = [1,1,1,1,1,1]
                h.constraint_frame.w = 1
                action.pose = h
                action.poses.poses.append(h)
            
            #if action.pose.pose.position.x>.67 or action.pose.pose.position.z < -0.01 or action.pose.pose.position.y>.28:
            #    self._gui_pub.publish(String("out_of_reach"))
            #    return        

            self._gui_pub.publish(String("good_move"))

            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            #print(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'mouse':
            arg = list_actions[1].split(":")
            action = Action()
            q = PyKDL.Rotation.RPY(float(arg[3]),float(arg[4]),float(arg[5])).GetQuaternion()
            p = PoseStamped()
            p.header.stamp = rospy.Time(0)
            p.header.frame_id = "rotated_camera"
            p.pose.position.x = float(arg[0])
            p.pose.position.y = float(arg[1])
            p.pose.position.z = float(arg[2])
            p.pose.orientation.x = q[0]
            p.pose.orientation.y = q[1]
            p.pose.orientation.z = q[2]
            p.pose.orientation.w = q[3]
            p = self._tfBuffer.transform(p,"panda_link0")
            h = HybridPose()
            h.sel_vector = [1,1,1,1,1,1]
            h.constraint_frame.w = 1
            h.pose = p.pose
            h.header = p.header
            #t = TransformStamped()
            #t.header = p.header
            #t.child_frame_id = "camera_goal"
            #t.transform.translation = p.pose.position
            #t.transform.rotation = p.pose.orientation
            #self._br.sendTransform(t)
            
            action.type = action.VIEW
            action.pose = h
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "go":
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "go_camera", rospy.Time(0)) 
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "reset_position":
            #self._panda_command.publish(String("release"))
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.RESET
            pose = HybridPose()
            pose.constraint_frame.w = 1
            #pose.position.x = 0.35
            #pose.position.y = 0.
            #pose.position.z = 0.7
            #pose.position.x = 0.3
            #pose.position.y = 0.
            #pose.position.z = 0.5
            #q = tf.transformations.quaternion_from_euler(np.pi,0,-np.pi/2)
            #pose.orientation.x = q[0]
            #pose.orientation.y = q[1]
            #pose.orientation.z = q[2]
            #pose.orientation.w = q[3]
            action.poses.poses.append(pose)
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop_sim":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.SIM
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'remove':
            cmd = list_actions[1].split(":")

            marker = Marker()
            if cmd[0] == "all":
                marker.action = marker.DELETEALL
                self._marker_pub.publish(marker)
                return
            marker.action = marker.DELETE
            marker.ns = cmd[0]
            marker.id = int(cmd[1])
            self._marker_pub.publish(marker)
            return
        
        list_actions = list_actions[1].split(",")
        #for action in list_actions:
        #    cmd = action.split(":")
        #    if len(cmd)>1 and cmd[1].find(",") != -1:
        #        try:
        #            #Only used if necessary?
        #            image = ros_numpy.numpify(rospy.wait_for_message("depth_to_rgb/image_raw", Image,timeout=1))
        #            break
        #        except Exception as e:
        #            print(e)
        #            return
        
        if self._depth is None:
            return
        
        if command_type == "play":
            index = int(list_actions[0].split("_")[1])
            actions = self.parse_actions(self._behaviors[index])    
        else:
            actions = self.parse_actions(list_actions)
        if actions is None:
            return

        cmd = Command()
        if command_type == "exec" or command_type == "play":
            cmd.type = cmd.EXEC
        if command_type == "sim":
            cmd.type = cmd.SIM
        if command_type == "viz":
            cmd.type = cmd.VIZ
        if command_type == "edit":
            cmd.type = cmd.EDIT
        for action in actions:
            cmd.core_action.append(action)
        ##print(cmd)
        if cmd.type != cmd.VIZ:
            self._command_pub.publish(cmd)

    def check_triggers(self):
        if self._moving or self._pause_autonomy or self._waiting_world_state:
            return

        #t = types.SimpleNamespace()
        #t.view_point = PoseStamped()
        #t.object = "screw"
        #t.conditions = "pix_pose:1200-1350_750-950"
        #t.behavior = 0
        #self._triggers = [t]
        to_trigger = []
        for name in self._triggers:
            print("testing trig")
            t = self._triggers[name]
            if type(t.conditions) == str:
                continue
            t.name = name
            t.candidates = self.get_candidates(t.conditions)
            print(t.candidates)
            actions = self.parse_actions(t.behavior.split(","),t.candidates) 
            if actions is None:
                continue 
            to_trigger.append(t)
        to_trigger = np.array(to_trigger)
        print(len(to_trigger))
        if len(to_trigger)>1:
            #Apply priority rules
            priorities = np.array([t.priority for t in to_trigger])
            if len(np.where(priorities == max(priorities))[0]) == 1:
                self.run_trigger(to_trigger[np.argmax(priorities)])
            else:
                #if not, inform frontend
                self._conflict = [t.name for t in to_trigger[np.where(priorities == max(priorities))[0]]]
                msg = "conflict;"+",".join(self._conflict)
                self._event_pub.publish(String(msg))
                self._pause_autonomy = True
        elif len(to_trigger) == 1:    
            self.run_trigger(to_trigger[0])
            

    def run_trigger(self, t):      
        behavior = t.behavior
        p = t.candidates[0]
        if "MoveDiscrete" in t.behavior or "Tighten" in t.behavior or "Loosen" in t.behavior:
            behavior=behavior.replace(p.type.data,self.get_poi_name(p))
        actions = self.parse_actions(behavior.split(","),t.candidates) 
        if actions is None:
            return 
        self._event_pub.publish(String("executing_trigger;"+t.name))
        cmd = Command()
        cmd.type = cmd.EXEC
        for action in actions:
            cmd.core_action.append(action)
        self._command_pub.publish(cmd)
        return

    def get_candidates(self, conditions):
        candidates = self._pois
        for condition in conditions:
            next_candidates = []
            for p in candidates:
                if condition.item != p.type.data:
                    next_candidates.append(p)
                    continue
                if self.test_condition(condition, p):
                    next_candidates.append(p)
                else:
                    if condition.test == "IsNotIn":
                        print("found one")
                        return []
            
            if condition.test != "IsNotIn":
                candidates = next_candidates
        return candidates
    
    def test_condition(self, condition, p):
        if condition.item != p.type.data:
            return False
        if condition.test == "IsIn":
            return self.point_in_hull((p.pose.pose.position.x,p.pose.pose.position.y),self.get_zone(condition.zone))
        if condition.test == "IsNotIn":
            return not self.point_in_hull((p.pose.pose.position.x,p.pose.pose.position.y),self.get_zone(condition.zone))
        if condition.test == "HasState":
            return condition.state in p.state.data.split(',')

    def generalize_behavior(self, behavior, object_type, target):
        actions = behavior.split(";")
        found = False
        for action in actions:
            for arg in action.split(":"):
                for item in arg.split("-"):
                    if item.startswith(object_type):
                        print("found")
                        print(target)
                        return behavior.replace(item,target)
        return None 

    def comp_conditions(self, a, b):
        if "HasState" in a:
            return -1
        if "HasState" in b:
            return 1
        if "IsNotIn" in a:
            return -1
        if "IsNotIn" in b:
            return 1
        return 0

    def parse_conditions(self, list_conditions):
        #screwM5-IsNotIn-200_400_500_500
        if list_conditions[0].startswith("button"):
            return list_conditions[0]
        to_return = []

        cmp = cmp_to_key(self.comp_conditions)

        list_conditions.sort(key=cmp)

        for condition in list_conditions:
            c = types.SimpleNamespace()
            args = condition.split("-")
            c.item = args[0]
            c.test = args[1]
            if c.test == "IsIn" or c.test == "IsNotIn":
                zone = args[2]
                if len(zone.split("_")) == 4:
                    zone = self.get_hull_from_pixel(zone)
                c.zone = zone
            if c.test == "HasState":
                c.state = args[2]
            to_return.append(c)
        return to_return

    def parse_actions(self, list_actions, candidates=None):
        actions = []
        moved = {}
        print("****************************************************")
        print("parsing")
        for action in list_actions:
            cmd = action.split(":")
            print(action)
        
            name = cmd[0]
            item = ""
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            #Get item name
            if cmd[0] == "Reset":
                action.poses.header.frame_id = REFERENCE_FRAME
                pose = HybridPose()
                pose.constraint_frame.w = 1
                action.poses.poses.append(pose)   
            elif name == "MoveZone":
                args = cmd[1].split("-")
                pattern = args[3]
                item_type = args[0]
                zone_a = self.get_zone(args[1])

                if zone_a is None:
                    return

                item = self.find_item_in_zone(item_type,zone_a,moved,candidates)
                if item is None:
                    print("no item found")
                    return None
                item_name = self.get_poi_name(item)
                print(item)

                #if pattern.startswith("box"):
                #    try:
                #        t_dest = self._tfBuffer.lookup_transform(REFERENCE_FRAME, pattern, rospy.Time(0)) 
                #    except:
                #        print("no box named "+str(pattern))
                #        continue 
                #    action.item = String(item_name+"-"+pattern)
                #    t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item_name, rospy.Time(0)) 
                #    pose = self.get_pose_from_trans(t)
                #    action.pose = pose
                #    action.poses.poses.append(pose) 
                #    pose = self.get_pose_from_trans(t_dest)
                #    action.poses.poses.append(pose)
                #    action.type = action.MOVE_OBJECT
                #    moved[item_name]=action.poses.poses[-1]
                #    actions.append(action)
                #    continue

                zone_b = self.get_zone(args[2])

                if zone_b is None:
                    return
                if pattern == "holder" or pattern == "box":
                    dest = self.find_item_in_zone(pattern,zone_b,moved,candidates)
                    if dest is None:
                        return None
                    
                    action.item = String(item_name+"-"+self.get_poi_name(dest))
                    #t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item_name, rospy.Time(0)) 
                    print(item)
                    pose = self.get_hybrid_pose(item.pose) #self.get_pose_from_trans(t)
                    action.pose = pose
                    action.poses.poses.append(pose)
                    #tv6 = self._tfBuffer.lookup_transform(REFERENCE_FRAME, self.get_poi_name(dest), rospy.Time(0)) 
                    pose2 = self.get_hybrid_pose(dest.pose)#self.get_pose_from_trans(t)
                    action.poses.poses.append(pose2)
                    action.type = action.MOVE_OBJECT
                    moved[item_name]=action.poses.poses[-1]
                    print("------------------------------------------------")
                    print(moved)
                    print(action)
                    actions.append(action)
                    continue
                elif pattern == "mid":
                    destination = zone_b.points.mean(0)
                else:
                    destination = self.find_free_space_in_zone(item_type,zone_b, pattern,moved)
                    if destination is None:
                        print("full destination")
                        return None
                
                item_str = self.get_poi_name(item)
                #t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item_str, rospy.Time(0)) 
                start = self.get_hybrid_pose(item.pose)#self.get_pose_from_trans(t)

                goal = self.get_hybrid_pose(PoseStamped())
                goal.pose.orientation.w = 1
                goal.header.frame_id = REFERENCE_FRAME
                goal.pose.position.x = destination[0]
                goal.pose.position.y = destination[1]

                action.poses.poses.append(start)
                action.poses.poses.append(goal)
                action.type = action.MOVE_OBJECT
                action.pose = action.poses.poses[0]
                action.item.data = item_str
                moved[item_str]=action.poses.poses[-1]

            elif name == "MovePixel":
                action.type = action.MOVE_UNKNOWN
                points = cmd[1].split('_')
                h_start = self.get_rotated_point(points[0])
                h_end = self.get_rotated_point(points[1])
                if h_start == None or h_end == None:

                    return None
                action.pose = h_start
                action.poses.poses.append(h_start)
                action.poses.poses.append(h_end)
                action.item = String(cmd[1])
                
                for p in action.poses.poses:
                    print(p.pose.position)
                    if p.pose.position.x>.67 or p.pose.position.z < -0.05 or p.pose.position.y>.30:
                        self._gui_pub.publish(String("out_of_reach"))
                        return None    

                actions.append(action)

                t = TransformStamped()
                t.header = h_start.header
                t.child_frame_id = "goal"
                t.transform.translation = h_start.pose.position
                t.transform.rotation = h_start.pose.orientation
                self._br.sendTransform(t)
                continue

            elif name == "Wipe":
                coords = cmd[1].split('_')
                h_grasp = self.get_rotated_point(coords[0])
                if h_grasp == None:
                    return None 
                action.poses.poses.append(h_grasp)
                action.pose = h_grasp
                for coord in coords[1:]:
                    coord = coord.split(',')
                    pose = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
                    if pose == None:
                        return None 
                    pose = self.get_hybrid_pose(self._tfBuffer.transform(pose,REFERENCE_FRAME))
                    pose.pose.orientation.x = 0
                    pose.pose.orientation.y = 0
                    pose.pose.orientation.z = 0
                    pose.pose.orientation.w = 1
                    action.poses.header = pose.header
                    action.poses.poses.append(pose)
                action.item = String(cmd[1])
            elif cmd[1].find(",") == -1: 
                item_list = cmd[1].split('-')
                for item in item_list:
                    if item in moved.keys():
                        action.poses.poses.append(moved[item])
                    else:
                        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item, rospy.Time(0)) 
                        pose = self.get_pose_from_trans(t)
                        action.poses.poses.append(pose)
                if cmd[0] == "MoveDiscrete":
                    action.item = String(cmd[1])
                    moved[item_list[0]]=action.poses.poses[-1]
                    moved[item_list[0]].pose.position.z+=.015
                else:
                    action.item = String(item_list[0])
                action.pose = action.poses.poses[0]
            else:
                return None

            #for p in action.poses.poses:
            #    if p.pose.position.x>.67 or p.pose.position.z < 0 or p.pose.position.y>.28:
            #        self._gui_pub.publish(String("out_of_reach"))
            #        return        

            self._gui_pub.publish(String("good_move"))

            action.type = self.get_action_from_name(action, name)

            actions.append(action)
        return actions

    def get_zone(self, id):
        zone = None
        if len(id.split("_")) == 4:
            zone = self.get_hull_from_pixel(id)
        else:
            try:
                zone = self._zones[id]
            except:
                print("no zone named "+id)
        return zone

    def find_item_in_zone(self, item_type, zone, moved = {}, candidates = None):
        print("Looking for:" + item_type)
        if candidates is None:
            candidates = self._pois
        print(len(candidates))
        print(zone)
        for p in candidates:
            print(p.type.data)
            if p.type.data != item_type:
                continue
            if type(zone) == str:
                try:
                    zone = self._zones[zone]
                except:
                    print("wrong zone")
                    return None

            position = p.pose.pose.position
            if self.get_poi_name(p) in moved.keys():
                position = moved[self.get_poi_name(p)].pose.position

            if type(zone) == ConvexHull:
                if self.point_in_hull((position.x,position.y),zone):
                    toreturn = copy.deepcopy(p)
                    toreturn.pose.pose.position = position
                    return toreturn
        print("no candidates")
        return None
    
    def find_free_space_in_zone(self,item_type,zone, pattern, moved = {}):
        cols = int(pattern.split("x")[0])
        rows = int(pattern.split("x")[1])
        points = zone.points
        left = np.linspace(points[0], points[3], rows+1)
        right = np.linspace(points[1], points[2], rows+1)
        bot = np.linspace(left[0], right[0], cols+1)
        for i in range(rows):
            top = bot
            bot = np.linspace(left[i+1], right[i+1], cols+1)
            for j in range(cols):
                hull = ConvexHull([top[j],top[j+1],bot[j+1],bot[j]])
                if self.find_item_in_zone(item_type, hull, moved) is None:
                    return hull.points.mean(0)
        return None
        
    def get_hull_from_pixel(self, coord):
        [x,y,w,h] = [int(c) for c in coord.split("_")]
        p1 = self.get_table_intersection(.985*x,y+22)
        p2 = self.get_table_intersection(.985*x+w,y+22)
        p3 = self.get_table_intersection(.985*x+w,y+h+22)
        p4 = self.get_table_intersection(.985*x,y+h+22)
        
        points = np.array([p1,p2,p3,p4])
        return ConvexHull(points)

    def get_table_intersection(self,x,y):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)

        point = Point()
        point.x=p3d[0]
        point.y=p3d[1]
        point.z=p3d[2]
        #return point

        p = PoseStamped()
        p.header.frame_id = CAMERA_FRAME
        p.header.stamp = rospy.Time(0)
        p.pose.position = point
        p.pose.orientation.w = 1
        p = self._tfBuffer.transform(p,REFERENCE_FRAME)

        camera = self._tfBuffer.lookup_transform(REFERENCE_FRAME, CAMERA_FRAME, rospy.Time(0)).transform
        
        l = camera.translation.z / (camera.translation.z-p.pose.position.z)
        x = camera.translation.x + l * (p.pose.position.x-camera.translation.x)
        y = camera.translation.y + l * (p.pose.position.y-camera.translation.y)

        return (x,y)

    def point_in_hull(self, point, hull, tolerance=1e-12):
        if hull is None:
            return False
        return all(
            (np.dot(eq[:-1], point) + eq[-1] <= tolerance)
            for eq in hull.equations)

    def get_poi_name(self,p):
        return p.type.data+"_"+str(p.id)

    def get_action_from_name(self, a, name):
        if name == 'Wipe':
            return a.WIPE
        if name == 'Grasp':
            return a.GRASP
        if name == 'Release':
            return a.RELEASE
        if name == 'MoveContact':
            return a.MOVE_TO_CONTACT
        if name == 'Go':
            return a.MOVE
        if name == 'Tighten':
            return a.SCREW
        if name == 'Loosen':
            return a.UNSCREW
        if name == 'Pick':
            return a.PICK
        if name == 'Place':
            return a.PLACE 
        if name == 'MoveDiscrete' or name == 'MoveZone':
            return a.MOVE_OBJECT
        if name == 'Screw':
            return a.SCREW
        if name == 'Unscrew':
            return a.UNSCREW
        if name == 'Inspect':
            return a.INSPECT
        if name == 'Push':
            return a.PUSH
        if name == 'MoveUnknown':
            return a.MOVE_UNKNOWN
        if name == 'Reset':
            return a.RESET
        if name == 'Pull':
            return a.PULL
        if name == 'Drop':
            return a.DROP

    def distance(self, p1, p2):
        return np.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2+(p1.z-p2.z)**2)

    def run(self):
        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown():
            self.publish_pois()
            try:
                self.check_triggers()
            except Exception as e:
                print(e)
                
            r.sleep()

    def signal_handler(self, signal, frame):
        sys.exit()

if __name__ == "__main__":
    rospy.init_node('parser')
    parser = Parser()
    signal.signal(signal.SIGINT, parser.signal_handler)
    parser.run()
